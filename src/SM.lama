-- Stack machine.

import List;
import Array;
import Collection;
import World;
import State;
import Expr;
import Buffer;
import Fun;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn (i) {
  case i of
    READ      -> sprintf ("READ")
  | WRITE     -> sprintf ("WRITE")
  | BINOP (s) -> sprintf ("BINOP %s", s)
  | LD    (x) -> sprintf ("LD %s", x)
  | ST    (x) -> sprintf ("ST %s", x)
  | CONST (n) -> sprintf ("CONST %d", n)
  esac
}

public fun showSM (prg) {
  map (fun (i) {showSMInsn (i) ++ "\n"}, prg).stringcat
}

fun initEvalEnv (insns) {
    local map =
        fix (fun (rec) {
            fun ([m, insns]) {
                case insns of
                    {}               -> m
                | LABEL (lab) : tl -> rec ([addMap (m, lab, insns), tl])
                | _ : tl           -> rec ([m, tl])
                esac
            }
        }) $ [emptyMap (compare), insns];
                                                                                                              
    [fun (l) {
        case findMap (map, l) of Some (insns) -> insns esac
    }]
}

-- Accessor function
fun fromLabel (env, lab) {
      env [0] (lab)
}

-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration
fun eval (env, c, insns) {
    case insns of
        {} -> return c
    |   p -> local i = insns[1], s = c[0], d = c[1], w = c[2];
        case insns[0] of
            LD (x) : e -> eval(env, [singleton(d(x)) +++ s, d, w], i)
        |   ST (x) : e -> eval(env, [s[1], d <- [x, s[0]], w], i)
        |   CONST(c) : e-> eval(env, [singleton(c) +++ s, d, w], i)
        |   BINOP(op) : e-> eval(env, [singleton(calcBinOp(op, s[1][0], s[0])) +++ s[1][1], d, w], i)
        |   READ : e -> local read = readWorld(w);
                    local var = read[0];
                    local new_w = read[1];
                    return eval(env, [singleton(var) +++ s, d, new_w], i)
        |   WRITE : e -> eval(env, [s[1], d, writeWorld(s[0], w)], i)
        |   LABEL(st) : e -> eval(env, c, e)
        |   JMP(l)      : e -> eval(env, c, fromLabel(env, l))
        |   CJMP(cond, l)  : e -> case s of cmp : sst -> case cond of
                                                            "z" -> case cmp of
                                                                       0 -> eval(env, c, fromLabel (env, l))
                                                                   | _ -> eval(env, c, e)
                                                                   esac
                                                         |  "nz" -> case cmp of
                                                                        0 -> eval(env, c, e)
                                                                    |   _ -> eval(env, c, fromLabel (env, l))
                                                                    esac
                                                        esac
                                  esac                      
        esac
    esac
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  eval ([{}, emptyState, createWorld (input)], insns)[2].getOutput
}

-- Compilation environment: generates labels
fun makeCompEnv (n) {
      [fun () {
        [sprintf ("L%d", n), makeCompEnv (n+1)]
      }]
}

fun initCompEnv () {
      makeCompEnv (0)
}

-- Accessor function: generates one label
fun genLabel (env) {
      env [0] ()
}

fun genLabels (env, n) {
    fun inner (env, n) {
        if n == 0
        then singleton (env)
        else case env.genLabel of
                [lab, env] -> lab : inner (env, n-1)
             esac
        fi
    }

    listArray (inner (env, n))
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list (of, possibly, lists)
-- of stack machine instructions
fun compileExpr (expr) {
    case expr of
        Var (var) -> return singleton (LD (var))
    |   Const (c) -> return singleton (CONST (c))
    |   Binop (op, left, right) -> return compileExpr (left) +++ compileExpr (right) +++ singleton (BINOP (op))
    esac
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {
    fun compileEnv(env, stmt) {
        case stmt of
            Seq (stmt1, stmt2) -> case compileEnv(env, stmt1) of
                                      [env, stmt1] -> case compileEnv(env, stmt2) of 
                                                          [env, stmt2] -> [env, stmt1 +++ stmt2]
                                                      esac
                                  esac
        |   Assn (x, expr) -> [env, compileExpr (expr) +++ singleton (ST (x))]
        |   Read (x) -> [env, {READ, ST (x)}]
        |   Write (e) -> [env, compileExpr (e) +++ singleton (WRITE)]
        |   Skip -> [env, {}]
        |   If (expr, s1, s2) -> case genLabels(env, 2) of 
                                    [lb_else, lb_fi, env1] -> case compileEnv(env1, s1) of 
                                                                  [env2, stmt1] -> case compileEnv(env2, s2) of 
                                                                                       [env3, stmt2] -> [env3, compileExpr(expr) +++ singleton(CJMP("z", lb_else )) +++ stmt1 +++ singleton(JMP(lb_fi)) +++ singleton(LABEL (lb_else)) +++ stmt2 +++ singleton(LABEL (lb_fi))]
                                                                                   esac
                                                              esac
                                 esac
        |   While(expr, s) -> case genLabels(env, 2) of 
                                  [label1, label2, env1] -> case compileEnv(env1, s) of 
                                                                [env2, insts] -> [env2, {JMP(label2), LABEL(label1)} +++ insts +++ singleton(LABEL(label2)) +++ compileExpr(expr) +++ singleton(CJMP("nz", label1))]
                                                            esac
                              esac
        |   Repeat(s, expr) -> case genLabels(env, 1) of 
                                   [label, env1] -> case compileEnv(env1, s) of 
                                                        [env2, insts] -> [env2, singleton(LABEL(label)) +++ insts +++ compileExpr(expr) +++ singleton(CJMP("z", label))]
                                                    esac
                               esac
        esac
    }
    compileEnv(initCompEnv (), stmt)[1]
}
